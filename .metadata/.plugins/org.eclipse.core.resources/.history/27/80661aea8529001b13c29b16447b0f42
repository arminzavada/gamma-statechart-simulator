package com.triad.school.gamma.simulator.query

import com.triad.school.gamma.simulator.active_state.Active_statePackage
import hu.bme.mit.gamma.statechart.statechart.StatechartModelPackage
import org.apache.log4j.Logger
import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.viatra.query.runtime.api.ViatraQueryEngine
import org.eclipse.viatra.query.runtime.emf.EMFScope
import org.eclipse.viatra.transformation.runtime.emf.modelmanipulation.IModelManipulations
import org.eclipse.viatra.transformation.runtime.emf.modelmanipulation.SimpleModelManipulations
import org.eclipse.viatra.transformation.runtime.emf.rules.batch.BatchTransformationRuleFactory
import org.eclipse.viatra.transformation.runtime.emf.transformation.batch.BatchTransformation
import org.eclipse.viatra.transformation.runtime.emf.transformation.batch.BatchTransformationStatements

class GammaStatechartSimulatorTransformation {
	val FireableTransitions queries = FireableTransitions.instance	
	
    extension Logger logger = Logger.getLogger(GammaStatechartSimulatorTransformation)

    /* Transformation-related extensions */
    extension BatchTransformation transformation
    extension BatchTransformationStatements statements
    
    /* Transformation rule-related extensions */
    extension BatchTransformationRuleFactory = new BatchTransformationRuleFactory
    extension IModelManipulations manipulation
    
	val extension StatechartModelPackage statePackage = StatechartModelPackage.eINSTANCE
	val extension Active_statePackage activePackage = Active_statePackage.eINSTANCE

    protected ViatraQueryEngine engine

    new(Resource resource) {
    	//val factory = Active_stateFactory.eINSTANCE
    	//val container = factory.createActiveStateContainer
    	
        // Create EMF scope and EMF IncQuery engine based on the resource
		//val resourceSet = new ResourceSetImpl
		//resourceSet.resources.add(resource)
		//val active_stateResource = resourceSet.createResource(URI.createURI(""))
		//active_stateResource.contents.add(container)
        val scope = new EMFScope(resource.resourceSet)
        engine = ViatraQueryEngine.on(scope);
        queries.prepare(engine)
        
        manipulation = new SimpleModelManipulations(engine)
        transformation = BatchTransformation.forEngine(engine)
        	.addRule(initialNodeRule)
        	.addRule(requiredInterfacesRule)
            .build
        statements = transformation.transformationStatements
    }

    public def initialise() {
        debug('''Initialising transformation on:�resource.URI�''')        
        //requiredInterfacesRule.fireAllCurrent    
        try {
        	initialNodeRule.fireOne
        } catch (Exception e) {
    		println(e)
	    }
    }

    public def execute() {
        debug('''Executing transformation on:�resource.URI�''')        
    }

	val requiredInterfacesRule = createRule(RequiredInterfaces.instance).action[
    	println('''Required interface: "«it.interface»"''')
    ].build
    
	val initialNodeRule = createRule(InitialNode.instance).action[
    	println('''Initial node: "«it.state»"''')
    ].build

    def dispose() {
        if (transformation != null) {
            transformation.dispose
        }
        
        transformation = null
    }
}
